from helper import build_artist, build_artists_list, load_file, replace_punctuation
from artists import Song, Artist
from nltk.corpus import PlaintextCorpusReader
from nltk.corpus import brown, stopwords
from collections import defaultdict, Counter
import string
import os
import json
import nltk
import math

def get_hip_hop_counts(lyrics_corpus):
    """counts the occurance of all non-stopwords in the hip hop corpus.
    I ran into some unexpected error transforming the .txt hip hop corpus into an NLTK Text object,
    so used a Counter object instead.  This worked, but not quickly"""
    print "Getting hip hop counter"
    words_examined = 0
    counter = Counter()
    for word in lyrics_corpus.words():
        if word not in stopwords.words('english'):
            counter[word] += 1
            words_examined += 1
        if words_examined % 100000 == 0:
            print "Still working {0} words counted so far".format(words_examined)
    return counter

def get_corpus_count(corpus_text, word, label, corpus_words):
    """returns the number of times a word appears in a corpus, and adds that number
    to a dictionary representation of all words being compared across corpora.
    Params:
        corpus_text -> NLTK Text object representation of the corpus you want to search
        word        -> string representation of the word you're counting
        label       -> what you want the count (of how many times word occurs in corpus_text)
                        to be labeled
        corpus_words -> dictionary representation of all words being compared across
                        corpora"""
    count = corpus_text.count(word)
    corpus_words[word][label] = count
    
    return corpus_words

def get_word_counts(hip_hop_corpus, output_file='weights_output.json'):
    """gets the hip hip and brown corpus count for every unique word in the hip hop corpus,
    modulo stopwords.
    
    Right now, this function takes a while to run, because of how hip_hop_counter is built.
    To save ourselves from having to run this multiple times, the results of a single run
    are output as a .json file.  Future operations can call the output file directly"""
    brown_text = nltk.Text(word.lower() for word in brown.words())
    #hip_hop_text = nltk.Text(word for word in hip_hop_corpus.words())
    #TO DO: Fix bug that impedes representing hip_hop_corpus as a NLTK Text object
    corpus_words = defaultdict(dict)
    hip_hop_counter = get_hip_hop_counts(hip_hop_corpus)
    hip_hop_words = list(hip_hop_counter)
    
    word_count = 0
    for word in hip_hop_words:
        if word not in stopwords.words():
            corpus_words[word]['hiphop'] = hip_hop_counter[word]
            #corpus_words = get_corpus_count(hip_hop_text, word, 'hiphop', corpus_words)
            #TO DO: fix this!
            corpus_words = get_corpus_count(brown_text, word, 'brown', corpus_words)
            word_count += 1
        #if you don't worry about these kinds of things, comment out the counts/prints    
        if word_count % 10000 == 0:
            print "working on it, don't worry"
        
    with open(output_file, 'w') as file_:
        json.dump(corpus_words, file_, indent=4)
    
    #If you ever speed this up...
    #return corpus_words
        
def get_weights(input_file="weights_output.json"):
    """Loads weights from the output file generated by get_word_counts()"""
    data = load_file(input_file)
    word_weights = defaultdict(dict)
    for word, weights in data.items():
        brown_score = float(weights['brown'])*(16.5/1.1)
        hiphop_score = float(weights['hiphop'])
        if brown_score != 0:
            score = math.log(hiphop_score/float(brown_score))
            word_weights[word]['score'] = score
            word_weights[word]['brown'] = data[word]['brown']
            word_weights[word]['hiphop'] = data[word]['hiphop']
            #print word, ":", score
            
    return word_weights

def print_ranked_words(word_weights):
    """prints out the 30 least hip hop words and the 30 most hip hop words, as well as their
    distributions across both corpora"""
    words_by_weight = sorted(word_weights.keys(), key=lambda word:word_weights[word]['score'])
    for word in words_by_weight[:30]:
        print word,'\t',word_weights[word]['score'],'\t',word_weights[word]['brown'],'\t',word_weights[word]['hiphop']
    print "\n"*2    
    for word in words_by_weight[-30:][::-1]:
        print word,'\t',word_weights[word]['score'],'\t',word_weights[word]['brown'],'\t',word_weights[word]['hiphop']

def rank_artist_weights(word_weights):
    """Builds an artists list and ranks each artists by their hip hop scores.  Returns a version of
    the original artists list sorted by hip hop score.
    
    Hip hop score per song is determined by adding the hip hop score of each hip hop word (i.e., words
    with a hip hop score; this function ignores stop words and words which were not present in the
    comparision corpus) in the song lyrics and dividing by the number of total hip hop words in the song.
    This is a built-in method of the Song class.
    
    Hip hop scores per artists is determined by averaging the hip hop score or all songs in that artists
    discography.  This is a built-in method of the Artist class.
    
    Hip hop scores are calculated on the fly (i.e., when Artist.get_hip_hop_score(word_weights) is
    called, not when the Artist object is built).  This is because only a small numbers of computations
    depend on this score, and it would be a drain on the module to calculate it every time an Artist or
    Song object was built.  The trade off is that this function may take ~2-3 minutes to run, because
    hip hop scores are expensive to calculate and this function calls them multiple times.
    
    Sorry about that."""
    all_artists = build_artists_list()
    artists = [artist for artist in all_artists if artist.get_hip_hop_score(word_weights) != 0]
    artists = sorted(artists, key=lambda artist:artist.get_hip_hop_score(word_weights))
    return artists

def print_artist_rankings(ranked_artists, word_weights, display=30):
    """prints the most and least hip hop artists in the corpus, up to the number specified in
    display"""
    for artist in ranked_artists[:display]:
        print artist.get_name(), ':', artist.get_hip_hop_score(word_weights)
        
    print "\n"*2
    
    for artist in ranked_artists[-display:]:
        print artist.get_name(), ':', artist.get_hip_hop_score(word_weights)
        
        
def main():
    print "Most and least hip hop words in the corpus..."
    word_weights = get_weights()
    print_ranked_words(word_weights)
    
    print "\n"
    print "Most and least hip hop artists in the corpus..."
    ranked_artists = rank_artist_weights(word_weights)
    print_artist_rankings(ranked_artists, word_weights)
    
if __name__ == '__main__':
    main()
